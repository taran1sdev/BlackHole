#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <vector>
#include <iostream>
#include <cmath>
#include <sstream>
#include <iomanip>
#include <cstring>
#include <chrono>
#include <fstream>
using namespace glm;
using namespace std;
using Clock = std::chrono::high_resolution_clock;

const double c = 299792458.0;
const double G = 6.67430e-11;
const double PI = 3.1415926535897932;

double lastTime = 0.0;
int nFrames = 0;
bool Gravity = false;
struct Ray;

// Simplify the camera - always point it at BH and use mouse for movement
struct Camera {
    // center of BH
    vec3 target = vec3(0.0f, 0.0f,0.0f);
    float radius =  6.34194e10f;
    float minRadius = 1e10f;
    float maxRadius = 1e12f;
    
    float hDir = 0.0f;
    float vDir = PI / 2.0f;
    float orbitVel = 0.01f;
    double zoomSpeed = 25e9f;
    
    bool dragging = false;
    bool moving = false;
    double lastX = 0.0, lastY = 0.0;

    // return position as a vector - always orbit the BH
    vec3 position() const {
        float clampedVertical = glm::clamp(vDir, 0.01f, float(PI) - 0.01f);
        return vec3(
                radius * sin(clampedVertical) * cos(vDir),
                radius * cos(clampedVertical),
                radius * sin(clampedVertical) * sin(vDir)
        );        
    }
    void updateState() {
        target = vec3(0.0f, 0.0f, 0.0f);
        if (dragging) {
            moving = true;
        } else {
           moving = false; 
        }
    }
    void getMouse(double x, double y) {
        float dx = float(x - lastX);
        float dy = float(y - lastY);
        
        if (dragging) {
            hDir += dx * orbitVel;
            vDir += dy * orbitVel;
            vDir = glm::clamp(vDir, 0.01f, float(PI) - 0.01f);
        }

        lastX = x;
        lastY = y;
        updateState();
    }
    void getClick(GLFWwindow* window, int button, int action, int mods) {
        if (button == GLFW_MOUSE_BUTTON_LEFT || button == GLFW_MOUSE_BUTTON_MIDDLE ) {
            dragging = true;
            glfwGetCursorPos(window, &lastX, &lastY);
        } else if (action == GLFW_RELEASE) {
            dragging = false;
        }        

        if (button == GLFW_MOUSE_BUTTON_RIGHT) {
            if (action == GLFW_PRESS) {
                Gravity = true;
            } else if (action == GLFW_RELEASE) {
                Gravity = false;
            }
        }
    }
    void getScroll(double x, double y) {
       radius -= y * zoomSpeed;
       radius = glm::clamp(radius, minRadius, maxRadius);
       updateState();
    }
};

Camera camera;

struct BlackHole {
    vec3 position;
    double mass;
    double r_s;

    BlackHole(vec3 pos, float m) : position(pos), mass(m) {
        // schwarzschild radius formula R = 2GM/c^2
        r_s = 2.0 * G * mass / (c*c);
    }
    bool Collide(float x, float y, float z) const {
        double dx = double(x) - double(position.x);
        double dy = double(y) - double(position.y);
        double dz = double(z) - double(position.z);
        double dist = (dx * dx) + (dy * dy) + (dz * dz);
        return dist < (r_s * r_s);
    }
};

// Mass of Sagittarius A
BlackHole SagA(vec3(0.0f, 0.0f, 0.0f), 8.54e36);

struct ObjectData {
    // xyzr
    vec4 posRadius;
    vec4 colour;
    float mass;
    vec3 velocity = vec3(0.0f, 0.0f, 0.0f);
};

// Draw some additional objects (stars / planets)
vector<ObjectData> objects = {
    { vec4(4e11f, 0.0f, 0.0f, 4e10f), vec4(1,1,0,1), 1.98892e30 },
    { vec4(0.0f, 0.0f, 4e11f, 4e10f), vec4(1,0,0,1), 1.98892e30 },
    { vec4(0.0f, 0.0f, 0.0f, SagA.r_s), vec4(0,0,0,1), static_cast<float>(SagA.mass) },
    { vec4(6e10f, 0.0f, 0.0f, 5e10f), vec4(0,1,0,1), 1.98892e30 }
};

struct Engine {
    GLFWwindow* window;
    
    GLuint gridShaderProg;
    GLuint shaderProg;
    GLuint computeProg = 0;
    
    GLuint quadVAO;
    GLuint texture;
    
    GLuint cameraUBO;
    GLuint diskUBO;
    GLuint objectsUBO;

    GLuint gridVAO = 0;
    GLuint gridEBO = 0;
    GLuint gridVBO = 0;
    int gridIndex = 0;

    const int WIDTH = 800;
    const int HEIGHT = 600;
    const float vWidth = 100000000000.0f;
    const float vheight = 750000000000.0f;

    Engine() {
        if (!glfwInit()) {
            cerr << "Failed to initialize GLFW\n";
            exit(-1);
        }         
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_ANY_PROFILE);

        window = glfwCreateWindow(WIDTH, HEIGHT, "Black Hole", nullptr, nullptr);
        if (!window) {
            cerr << "Failed to create window\n";
            glfwTerminate();
            exit(-1);
        }

        glfwMakeContextCurrent(window);
        glewExperimental = GL_TRUE;
        GLenum glewErr = glewInit();
        if (glewErr != GLEW_OK) {
            cerr << "Failed to initialize GLEW\n";
            glfwTerminate();
            exit(-1);
        }

        this->shaderProg = CreateShaderProgram();
        gridShaderProg = CreateShaderProgram("../shaders/grid.vert", "../shaders/grid.frag");

        computeProg = CreateComputeProgram("../shaders/geodesic.comp");

        glGenBuffers(1, &cameraUBO);
        glBindBuffer(GL_UNIFORM_BUFFER, cameraUBO);
        glBufferData(GL_UNIFORM_BUFFER, 128, nullptr, GL_DYNAMIC_DRAW);
        glBindBufferBase(GL_UNIFORM_BUFFER, 1, cameraUBO);

        glGenBuffers(1, &diskUBO);
        glBindBuffer(GL_UNIFORM_BUFFER, diskUBO);
        glBufferData(GL_UNIFORM_BUFFER, sizeof(float) * 4, nullptr, GL_DYNAMIC_DRAW);
        glBindBufferBase(GL_UNIFORM_BUFFER, 2, diskUBO);

        glGenBuffers(1, &objectsUBO);
        glBindBuffer(GL_UNIFORM_BUFFER, objectsUBO);
        GLsizeiptr objUBOSize = 
            sizeof(int) 
            + 3 * sizeof(float) 
            + 16 * (sizeof(vec4) + sizeof(vec4))
            + 16 * sizeof(float);
        glBufferData(GL_UNIFORM_BUFFER, objUBOSize, nullptr, GL_DYNAMIC_DRAW);
        glBindBufferBase(GL_UNIFORM_BUFFER, 3, objectsUBO);

        auto result = QuadVAO();
        this->quadVAO = result[0];
        this->texture = result[1];
    }
    void generateGrid(const vector<ObjectData>& objects) {
        const int gridSize = 25;
        const float spacing = 1e10f;

        vector<vec3> vertices;
        vector<GLuint> indices;

         for (int z = 0; z <= gridSize; ++z) {
             for (int x = 0; x <= gridSize; ++x) {
                 float worldX = (x - gridSize / 2) * spacing;
                 float worldZ = (z - gridSize / 2) * spacing;

                 float y = 0.0f;

                 for (const auto& obj : objects) {
                     vec3 objPos = vec3(obj.posRadius);
                     double mass = obj.mass;
                     double radius = obj.posRadius.w;

                     double r_s = 2.0 * G * mass / (c * c);
                     double dx = worldX - objPos.x;
                     double dz = worldZ - objPos.z;
                     double dist = sqrt(dx * dx + dz * dz);

                     if (dist > r_s) {
                         double deltaY = 2.0 * sqrt(r_s * (dist - r_s));
                         y += static_cast<float>(deltaY) - 3e10f;
                     } else {
                         y += 2.0f * static_cast<float>(sqrt(r_s * r_s)) - 3e10f;
                     }
                 }
                 
                 vertices.emplace_back(worldX, y, worldZ);
             }
         }

         for (int z = 0; z < gridSize; ++z) {
             for (int x = 0; x < gridSize; ++x) {
                 int i = z * (gridSize + 1) + x;
                 indices.push_back(i);
                 indices.push_back(i + 1);

                 indices.push_back(i);
                 indices.push_back(i + gridSize + 1);
             }
         }

         if (gridVAO == 0) glGenVertexArrays(1, &gridVAO);
         if (gridVBO == 0) glGenBuffers(1, &gridVBO);
         if (gridEBO == 0) glGenBuffers(1, &gridEBO);

         glBindVertexArray(gridVAO);

         glBindBuffer(GL_ARRAY_BUFFER, gridVBO);
         glBufferData(GL_ARRAY_BUFFER, 
                 vertices.size() *  sizeof(vec3), 
                 vertices.data(), GL_DYNAMIC_DRAW);
        
         glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, gridEBO);
         glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                 indices.size() * sizeof(GLuint),
                 indices.data(),
                 GL_STATIC_DRAW);

         glEnableVertexAttribArray(0);
         glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(vec3), (void*)0);

         gridIndex = indices.size();

         glBindVertexArray(0);
    }
    void drawGrid(const mat4& viewProj) {
        glUseProgram(gridShaderProg);
        glUniformMatrix4fv(glGetUniformLocation(gridShaderProg, "viewProj"),
                1, GL_FALSE, glm::value_ptr(viewProj));
        glBindVertexArray(gridVAO);

        glDisable(GL_DEPTH_TEST);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        glDrawElements(GL_LINES, gridIndex, GL_UNSIGNED_INT, 0);

        glBindVertexArray(0);
        glEnable(GL_DEPTH_TEST);
    }
    void drawFullscreenQuad() {
        glUseProgram(shaderProg);
        glBindVertexArray(quadVAO);

        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture);
        glUniform1i(glGetUniformLocation(shaderProg, "screenTexture"), 0);

        glDisable(GL_DEPTH_TEST);
        glDrawArrays(GL_TRIANGLE_STRIP, 0, 6);
        glEnable(GL_DEPTH_TEST);
    }
    GLuint CreateShaderProgram() {
        const char* vertexShaderSource = R"(
        #version 460 core
        layout (location = 0) in vec2 aPos;
        layout (location = 1) in vec2 aTexCoord;
        out vec2 TexCoord;
        void main() {
        gl_Position = vec4(aPos, 0.0, 1.0);
        TexCoord = aTexCoord;
        })";
        
        const char* fragmentShaderSource = R"(
        #version 460 core
        in vec2 TexCoord;
        out vec4 FragColour;
        uniform sampler2D screenTexture;
        void main() {
            FragColour = texture(screenTexture, TexCoord);
        })";

        GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertexShader, 1, &vertexShaderSource, nullptr);
        glCompileShader(vertexShader);

        GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragmentShader, 1, &fragmentShaderSource, nullptr);
        glCompileShader(fragmentShader);

        GLuint shaderProgram = glCreateProgram();
        glAttachShader(shaderProg, vertexShader);
        glAttachShader(shaderProg, fragmentShader);
        glLinkProgram(shaderProg);

        glDeleteShader(vertexShader);
        glDeleteShader(fragmentShader);

        return shaderProgram;
    };
    GLuint CreateShaderProgram(const char* vertPath, const char* fragPath) {
        auto loadShader = [](const char* path, GLenum type) -> GLuint {
            std::ifstream in(path);
            if (!in.is_open()) {
                std::cerr << "Failed to open shader\n";
                exit(-1);
            }
            std::stringstream ss;
            ss << in.rdbuf();
            std::string srcStr = ss.str();
            const char* src = srcStr.c_str();

            GLuint shader = glCreateShader(type);
            glShaderSource(shader, 1, &src, nullptr);
            glCompileShader(shader);

            GLint success;
            glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
            if (!success) {
                GLint logLen;
                glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLen);
                std::vector<char> log(logLen);
                glGetShaderInfoLog(shader, logLen, nullptr, log.data());
                std::cerr << "Shader compile error " << path << "\n" << log.data() << "\n";
                exit(-1);
            }
            return shader;
        };

        GLuint vertShader = loadShader(vertPath, GL_VERTEX_SHADER);
        GLuint fragShader = loadShader(fragPath, GL_FRAGMENT_SHADER);

        GLuint program = glCreateProgram();
        glAttachShader(program, vertShader);
        glAttachShader(program, fragShader);
        glLinkProgram(program);

        GLint lSuccess;
        glGetProgramiv(program, GL_LINK_STATUS, &lSuccess);
        if (!lSuccess) {
            GLint logLen;
            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLen);
            std::vector<char> log(logLen);
            glGetProgramInfoLog(program, logLen, nullptr, log.data());
            std::cerr << "Shader linking error:\n" << log.data() << "\n";
            exit(-1);
        } 

        glDeleteShader(vertShader);
        glDeleteShader(fragShader);

        return program;        
    }
    GLuint CreateComputeProgram(const char* path) {
        std::ifstream in(path);
        if (!in.is_open()) {
            std::cerr << "Failed to open compute shader\n";
            exit(-1);            
        }

        std::stringstream ss;
        ss << in.rdbuf();
        std::string srcStr = ss.str();
        const char* src = srcStr.c_str();

        GLuint cs = glCreateShader(GL_COMPUTE_SHADER);
        glShaderSource(cs, 1, &src, nullptr);
        glCompileShader(cs);
        GLint ok;
        glGetShaderiv(cs, GL_COMPILE_STATUS, &ok);
        if(!ok) {
            GLint logLen;
            glGetShaderiv(cs, GL_INFO_LOG_LENGTH, &logLen);
            std::vector<char> log(logLen);
            glGetShaderInfoLog(cs, logLen, nullptr, log.data());
            std::cerr << "Compute shader compile error:\n" << log.data() << "\n";
            exit(-1);
        }

        GLuint prog = glCreateProgram();
        glAttachShader(prog, cs);
        glLinkProgram(prog);
        glGetProgramiv(prog, GL_LINK_STATUS, &ok);
        if (!ok) {
            GLint logLen;
            glGetProgramiv(prog, GL_INFO_LOG_LENGTH, &logLen);
            std::vector<char> log(logLen);
            glGetProgramInfoLog(prog, logLen, nullptr, log.data());
            std::cerr << "Compute shader linking error:\n" << log.data() << "\n";
            exit(-1);
        }

        glDeleteShader(cs);
        return prog;
    }
    void dispatchCompute(const Camera& cam) {
        glBindTexture(GL_TEXTURE_2D, texture);
        glTexImage2D(GL_TEXTURE_2D,
                0,
                GL_RGBA8,
                WIDTH,
                HEIGHT,
                0,
                GL_RGBA,
                GL_UNSIGNED_BYTE,
                nullptr);

        glUseProgram(computeProg);
        uploadCameraUBO(cam);
        uploadDiskUBO();
        uploadObjectsUBO(objects);

        glBindImageTexture(0, texture, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA8);

        GLuint groupsX = (GLuint)std::ceil(WIDTH / 16.0f);
        GLuint groupsY = (GLuint)std::ceil(HEIGHT / 16.0f);
        glDispatchCompute(groupsX, groupsY, 1);

        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
    }
    void uploadCameraUBO(const Camera& cam) {
        struct UBOData {
            vec3 pos; float _pad0;
            vec3 right; float _pad1;
            vec3 up; float _pad2;
            vec3 forward; float _pad3;
            float tanHalfFov;
            float aspect;
            bool moving;
            int _pad4;
        } data;
        
        vec3 fwd = normalize(cam.target - cam.position());
        vec3 up = vec3(0, 1, 0);
        vec3 right = normalize(cross(fwd, up));
        up = cross(right, fwd);

        data.pos = cam.position();
        data.right = right;
        data.up = up;
        data.forward = fwd;
        data.tanHalfFov = tan(radians(60.0f * 0.5f));
        data.aspect = float(WIDTH) / float(HEIGHT);
        data.moving = cam.dragging;

        glBindBuffer(GL_UNIFORM_BUFFER, cameraUBO);
        glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(UBOData), &data);
    }
    void uploadObjectsUBO(const vector<ObjectData>& objs) {
        struct UBOData {
            int numObjects;
            float _pad0, _pad1, _pad2;
            vec4 posRadius[16];
            vec4 colour[16];
            float mass[16];
        } data;

        size_t count = std::min(objs.size(), size_t(16));
        data.numObjects = static_cast<int>(count);

        for (size_t i = 0; i < count; ++i) {
            data.posRadius[i] = objs[i].posRadius;
            data.colour[i] = objs[i].colour;
            data.mass[i] = objs[i].mass;
        }

        glBindBuffer(GL_UNIFORM_BUFFER, objectsUBO);
        glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(data), &data);
    }
    void uploadDiskUBO() {
        float r1 = SagA.r_s * 2.2f;
        float r2 = SagA.r_s * 5.2f;
        float num = 2.0;
        float thickness = 1e9f;
        float diskData[4] = { r1, r2, num, thickness };

        glBindBuffer(GL_UNIFORM_BUFFER, diskUBO);
        glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(diskData), diskData);
    }
    vector<GLuint> QuadVAO() {
        float quadVertices[] = {
            -1.0f,  1.0f,  0.0f, 1.0f,  
            -1.0f, -1.0f,  0.0f, 0.0f, 
            1.0f, -1.0f,  1.0f, 0.0f, 

            -1.0f,  1.0f,  0.0f, 1.0f,
            1.0f, -1.0f,  1.0f, 0.0f,
            1.0f,  1.0f,  1.0f, 1.0f
        };

        GLuint VAO, VBO;
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);

        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), quadVertices, GL_STATIC_DRAW);

        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4*sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4*sizeof(float), (void*)(2 *sizeof(float)));
        glEnableVertexAttribArray(1);

        GLuint tex;
        glGenTextures(1, &tex);
        glBindTexture(GL_TEXTURE_2D, tex);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glBindTexture(GL_TEXTURE_2D, tex);
        glTexImage2D(GL_TEXTURE_2D,
                0,
                GL_RGB8,
                WIDTH,
                HEIGHT,
                0,
                GL_RGBA,
                GL_UNSIGNED_BYTE,
                nullptr);
        vector<GLuint> VAOtexture = {VAO, tex};
        return VAOtexture;        
    }
    void renderScene() {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glUseProgram(shaderProg);
        glBindVertexArray(quadVAO);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture);
        glDrawArrays(GL_TRIANGLES, 0, 6);
        glfwSwapBuffers(window);
        glfwPollEvents();        
    };
};

Engine engine;

void setupCameraCallbacks(GLFWwindow* window) {
    glfwSetWindowUserPointer(window, &camera);

    glfwSetMouseButtonCallback(window, [](GLFWwindow* win, int button, int action, int mods) {
            Camera* cam = (Camera*)glfwGetWindowUserPointer(win);
            cam->getClick(win, button, action, mods);
            });
    glfwSetCursorPosCallback(window, [](GLFWwindow* win, double x, double y) {
            Camera* cam = (Camera*)glfwGetWindowUserPointer(win);
            cam->getMouse(x, y);
            });
    glfwSetCursorPosCallback(window, [](GLFWwindow* win, double x, double y) {
            Camera* cam = (Camera*)glfwGetWindowUserPointer(win);
            cam->getScroll(x, y);
            });
}

int main() {
    setupCameraCallbacks(engine.window);
    vector<unsigned char> pixels(engine.WIDTH * engine.HEIGHT * 3);

    auto t0 = Clock::now();
    lastTime = chrono::duration<double>(t0.time_since_epoch()).count();

    double lTime = glfwGetTime();
    int renderW = 800, renderH = 600, numSteps = 80000;
    while (!glfwWindowShouldClose(engine.window)) {
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        double now = glfwGetTime();
        double dt = now - lastTime;
        lTime = now;

        for (auto& obj : objects) {
            for (auto& obj2 : objects) {
                if (&obj == &obj2) continue;
                float dx = obj2.posRadius.x - obj.posRadius.x;
                float dy = obj2.posRadius.y - obj.posRadius.y;
                float dz = obj2.posRadius.z - obj.posRadius.z;
                float distance = sqrt(dx * dx + dy * dy + dz * dz);
                if (distance > 0) {
                    vector<double> direction = {dx / distance, dy / distance, dz / distance};
                    double Gforce = (G * obj.mass * obj2.mass) / (distance * distance);

                    double acc1 = Gforce / obj.mass;
                    std::vector<double> acc = 
                        {direction[0] * acc1, direction[1] * acc1, direction[2] * acc1};
                    if (Gravity) {
                        obj.velocity.x += acc[0];
                        obj.velocity.y += acc[1];
                        obj.velocity.z += acc[2];

                        obj.posRadius.x += obj.velocity.x;
                        obj.posRadius.y += obj.velocity.y;
                        obj.posRadius.z += obj.velocity.z;                        
                    }
                }
            }
        }

        engine.generateGrid(objects);
        
        mat4 view = lookAt(camera.position(), camera.target, vec3(0,1,0));
        mat4 proj = perspective(radians(60.0f), float(engine.WIDTH)/engine.HEIGHT, 1e9f, 1e14f);
        mat4 viewProj = proj * view;
        engine.drawGrid(viewProj);

        glViewport(0,0, engine.WIDTH, engine.HEIGHT);
        engine.dispatchCompute(camera);
        engine.drawFullscreenQuad();

        glfwSwapBuffers(engine.window);
        glfwPollEvents();
    }

    glfwDestroyWindow(engine.window);
    glfwTerminate();
    return 0;
}
