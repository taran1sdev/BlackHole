#version 460 core

layout (local_size_x = 8, local_size_y = 8) in;

layout (rgba32f, binding = 0) uniform image2D accumImage;

uniform vec2 resolution;
uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camRight;
uniform vec3 camUp;

uniform vec3 bh_position;
uniform float bh_rs;
uniform float bh_rg;

const float EPS = 1e-5;
const float PI = 3.14159265359;
const float R_MIN = 2.0 + 1e-3;
const float R_ESCAPE = 200.0;

// little helper - stops division by zero
float safeDiv(float num, float den) {
    return num / max(abs(den), EPS);
}

// Schwarzschild metric geodesic integration via Dormand-Prince 5(4)
struct GeoState {
    vec4 x; // t, r, theta, phi
    vec4 p; // pt, pr, ptheta, pphi
};

GeoState makeState(vec4 x, vec4 p) {
    GeoState s;
    s.x = x;
    s.p = p;
    return s;
}

GeoState geoAdd(GeoState a, GeoState b, float scale) {
    GeoState r;
    r.x = a.x + scale * b.x;
    r.p = a.p + scale * b.p;
    return r;
}

GeoState geoAdd2(GeoState a, GeoState b1, float s1, GeoState b2, float s2) {
    GeoState r;
    r.x = a.x + s1 * b1.x + s2 * b2.x;
    r.p = a.p + s1 * b1.p + s2 * b2.p;
    return r;
}

GeoState geoAdd3(GeoState a, GeoState b1, float s1,
        GeoState b2, float s2, GeoState b3, float s3) {
    GeoState r;
    r.x = a.x + s1 * b1.x + s2 * b2.x + s3 * b3.x;
    r.p = a.p + s1 * b1.p + s2 * b2.p + s3 * b3.p;
    return r;
}

GeoState geoSub(GeoState a, GeoState b) {
    GeoState r;
    r.x = a.x - b.x;
    r.p = a.p - b.p;
    return r;
}

GeoState clampState(GeoState s) {
    s.x.y = max(s.x.y, R_MIN);
    s.x.z = clamp(s.x.z, 0.001, PI - 0.001);
    return s;
}

// im not sure if this is correct - much more complicated that the 2D version..
GeoState geodesic_rhs(GeoState y) {
    float r     = max(y.x.y, R_MIN);
    float theta = y.x.z;
    float phi   = y.x.w;

    float pt   = y.p.x;
    float pr   = y.p.y;
    float pth  = y.p.z;
    float pphi = y.p.w;

    float sinTh = sin(theta);
    float cosTh = cos(theta);
    float sin2Th = 2.0 * sinTh * cosTh;

    float sinThSafe = (abs(sinTh) > EPS)
                      ? sinTh
                      : (sinTh >= 0.0 ? EPS : -EPS);

    float inv_r = 1.0 / r;
    float rm2   = r - 2.0;
    float inv_r_rm2 = 1.0 / (r * rm2);
    float r3    = r * r * r;

    vec4 dx;
    dx.x = pt;
    dx.y = pr;
    dx.z = pth;
    dx.w = pphi;


    // t-component
    float Gamma_t_tr = inv_r_rm2;
    float dpt = -2.0 * Gamma_t_tr * pt * pr;

    // r-component
    float Gamma_r_tt   = rm2 / r3;
    float Gamma_r_rr   = -inv_r_rm2;
    float Gamma_r_thth = (2.0 - r);
    float Gamma_r_phph = (2.0 - r) * sinTh * sinTh;

    float dpr = -(
          Gamma_r_tt   * pt   * pt
        + Gamma_r_rr   * pr   * pr
        + Gamma_r_thth * pth  * pth
        + Gamma_r_phph * pphi * pphi
    );

    // theta-component
    float Gamma_th_rth  = inv_r;
    float Gamma_th_phph = -0.5 * sin2Th;

    float dpth = -(
          2.0 * Gamma_th_rth * pr  * pth
        + Gamma_th_phph      * pphi * pphi
    );

    // phi-component
    float Gamma_ph_rph  = inv_r;
    float cotTh         = cosTh / sinThSafe;     

    float dpph = -(
          2.0 * Gamma_ph_rph * pr  * pphi
        + 2.0 * cotTh        * pth * pphi
    );

    vec4 dp = vec4(dpt, dpr, dpth, dpph);

    return makeState(dx, dp);
}
GeoState dp54_step(GeoState y, float h, out float err) {
    // coeffecients... Thank god for AI...
    const float a21 = 1.0 / 5.0;
    const float a31 = 3.0 / 40.0;
    const float a32 = 9.0 / 40.0;

    const float a41 = 44.0 / 45.0;
    const float a42 = -56.0 / 15.0;
    const float a43 = 32.0 / 9.0;

    const float a51 = 19372.0 / 6561.0;
    const float a52 = -25360.0 / 2187.0;
    const float a53 = 64448.0 / 6561.0;
    const float a54 = -212.0 / 729.0;

    const float a61 = 9017.0 / 3168.0;
    const float a62 = -355.0 / 33.0;
    const float a63 = 46732.0 / 5247.0;
    const float a64 = 49.0 / 176.0;
    const float a65 = -5103.0 / 18656.0;

    const float a71 = 35.0 / 384.0;
    const float a72 = 0.0;
    const float a73 = 500.0 / 1113.0;
    const float a74 = 125.0 / 192.0;
    const float a75 = -2187.0 / 6784.0;
    const float a76 = 11.0 / 84.0;

    const float b1 = 35.0 / 384.0;
    const float b2 = 0.0;
    const float b3 = 500.0 / 1113.0;
    const float b4 = 125.0 / 192.0;
    const float b5 = -2187.0 / 6784.0;
    const float b6 = 11.0 / 84.0;
    const float b7 = 0.0;

    const float b1s = 5179.0 / 57600.0;
    const float b2s = 0.0;
    const float b3s = 7571.0 / 16695.0;
    const float b4s = 393.0 / 640.0;
    const float b5s = -92097.0 / 339200.0;
    const float b6s = 187.0 / 2100.0;
    const float b7s = 1.0 / 40.0;
    
    GeoState k1 = geodesic_rhs(y);

    GeoState y2 = geoAdd(y, k1, h * a21);
    GeoState k2 = geodesic_rhs(y2);

    GeoState y3 = geoAdd2(y, k1, h * a31, k2, h * a32);
    GeoState k3 = geodesic_rhs(y3);

    GeoState y4 = geoAdd3(y, k1, h * a41, k2, h * a42, k3, h * a43);
    GeoState k4 = geodesic_rhs(y4);

    GeoState y5 = geoAdd3(y, k1, h * a51, k2, h * a52, k3, h * a53);
    y5 = geoAdd(y5, k4, h * a54);
    GeoState k5 = geodesic_rhs(y5);

    GeoState y6 = geoAdd3(y, k1, h * a61, k2, h * a62, k3, h * a63);
    y6 = geoAdd2(y6, k4, h * a64, k5, h * a65);
    GeoState k6 = geodesic_rhs(y6);

    GeoState y7 = geoAdd3(y, k1, h * a71, k3, h * a73, k4, h * a74);
    y7 = geoAdd2(y7, k5, h * a75, k6, h * a76);
    GeoState k7 = geodesic_rhs(y7);
    
    // 5th order solution - return value
    GeoState y5th = y;
    y5th.x += h * (b1 * k1.x + b2 * k2.x + b3 * k3.x + b4 * k4.x + b5 * 
            k5.x + b6 * k6.x + b7 * k7.x);
    y5th.p += h * (b1 * k1.p + b2 * k2.p + b3 * k3.p + b4 * k4.p + b5 *
            k5.p + b6 * k6.p + b7 * k7.p);

    // 4th order solution - for error estimate
    GeoState y4th = y;
    y4th.x += h * (b1s * k1.x + b2s * k2.x + b3s * k3.x + b4s * k4.x + b5s * 
            k5.x + b6s * k6.x + b7s * k7.x);
    y4th.p += h * (b1s * k1.p + b2s * k2.p + b3s * k3.p + b4s * k4.p + b5s *
            k5.p + b6s * k6.p + b7s * k7.p);

    //y5th = clampState(y5th);
    //y4th = clampState(y4th);

    vec4 dxErr = abs(y5th.x - y4th.x);
    vec4 dpErr = abs(y5th.p - y4th.p);

    err = max(
            max(max(dxErr.x, dxErr.y), max(dxErr.z, dxErr.w)),
            max(max(dpErr.x, dpErr.y), max(dpErr.z, dpErr.w))
    );

    return y5th;
}

// convert schwarzschild coordinates to cartesian
vec3 sphToCart(float r, float theta, float phi) {
    float sinTh = sin(theta);
    float cosTh = cos(theta);
    float sinPh = sin(phi);
    float cosPh = cos(phi);

    return vec3(
            r * sinTh * cosPh,
            r * cosTh,
            r * sinTh * sinPh
    );
}
// Volumetric accretion disk ray marching

// Doppler beaming

// HG scattering


void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    // return if pixel out of bounds
    if (pixel.x >= int(resolution.x) || pixel.y >= int(resolution.y))
        return;

    // normalize device coordinates
    vec2 uv = (vec2(pixel) + 0.5) / resolution * 2.0 - 1.0;
    float aspect = resolution.x / resolution.y;
    uv.x *= aspect;

    // camera ray
    vec3 rayDir = normalize(camForward +
            uv.x * camRight +
            uv.y * camUp
    );
    
    // camera position relative to BH
    vec3 rel = camPos - bh_position;
    float r0 = length(rel);

    // camera is inside the event horizon
    if (r0 < 2.5) {
        imageStore(accumImage, pixel, vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }
    
    // spherical coordinates
    float theta0 = acos(clamp(rel.y / r0, -1.0, 1.0));
    float phi0 = atan(rel.z, rel.x);
    
    vec3 e_r = rel / r0;

    float sinTh0 = sin(theta0);
    float cosTh0 = cos(theta0);
    float sinPh0 = sin(phi0);
    float cosPh0 = cos(phi0);

    vec3 e_theta = normalize(vec3(
            cosTh0 * cosPh0,
            -sinTh0,
            cosTh0 * sinPh0
    ));

    vec3 e_phi = normalize(vec3(
            -sinPh0,
            0.0,
            cosPh0
    ));
    
    // ray direction in local orthonormal triad
    float vr = dot(rayDir, e_r);
    float vth = dot(rayDir, e_theta);
    float vph = dot(rayDir, e_phi);

    vec3 v = normalize(vec3(vr, vth, vph));
    vr = v.x; vth = v.y; vph = v.z;
    
    float f0 = max(1.0 - 2.0 / r0, EPS);
    float sqrtF0 = sqrt(f0);

    float pt = 1.0 / sqrtF0;
    float pr = vr * sqrtF0;
    float pth = vth / r0;

    float sinTh0Safe = max(abs(sinTh0), 0.01);
    float pphi = vph / (r0 * sinTh0Safe);

    // initial state
    vec4 x0 = vec4(0.0, r0, theta0, phi0);
    vec4 p0 = vec4(pt, pr, pth, pphi);

    GeoState s = makeState(x0, p0);
        
    // parameters for integration
    float h = 0.2;
    const float tol = 1e-4;
    const float hMin = 1e-4;
    const float hMax = 1.0;

    vec3 finalColour = vec3(0.0);
    bool hitBH = false;
    bool escaped = false;

    for (int i = 0; i < 2000; ++i) {
        float err;
        GeoState sNext = dp54_step(s, h, err);

        if (err > EPS) {
            float safety = 0.85;
            float scale = safety * pow(tol / max(err, EPS), 0.2);
            scale = clamp(scale, 0.2, 4.0);
            float hNew = clamp(h * scale, hMin, hMax);
            
            // reject step and try again smaller
            if (err > tol && h > hMin) {
                h = hNew;
                continue;
            }

            h = hNew;
        }
        
        // accept step
        s = sNext;
        
        float r = s.x.y;
        float theta = s.x.z;
        float phi = s.x.w;
        
        // debug
        if (any(isnan(s.x)) || any(isnan(s.p))) {
            finalColour = vec3(1.0, 0.0, 1.0);
            break;
        }

        // black hole collision
        if (r < bh_rs * 1.001) {
            hitBH = true;
            finalColour = vec3(0.0);
            break;
        }
        
        // escape condition
        if (r > R_ESCAPE) {
            escaped = true;
            vec3 escapePos = sphToCart(r, theta, phi) + bh_position;
            vec3 escapeDir = normalize(escapePos - camPos);

            float t = 0.5 * (escapeDir.y + 1.0);

            finalColour = mix(vec3(0.02, 0.02, 0.05), vec3(0.5, 0.6, 0.9), t);
            break;
        }

    }

    if (!hitBH && !escaped) {
        finalColour = vec3(0.1, 0.1, 0.0);
    }
    imageStore(accumImage, pixel, vec4(finalColour, 1.0));
}
