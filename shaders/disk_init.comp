#version 460 core
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(rgba16f, binding = 0) writeonly uniform image3D diskVolume;

uniform float rMin;
uniform float rMax;
uniform float zMin;
uniform float zMax;

uniform float uTime;

const float PI = 3.14159265359;

float hash(vec3 p) {
    p = fract(p * 0.3183099 + vec3(0.1, 0.2, 0.3));
    p += dot(p, p.yzx + 19.19);
    return fract(p.x * p.y * p.z * 157.0);
}

float noise_3(vec3 p) {
    float n  = hash(p);
    float amp = 1.0;
    float freq = 1.0;
    
    for (int i = 0; i < 4; i++) {
        n += amp * hash(p * freq);
        freq *= 2.3;
        amp *= 0.45;
    }

    return n; 
}

void main() {
    ivec3 gid  = ivec3(gl_GlobalInvocationID);
    ivec3 size = imageSize(diskVolume);
    if (any(greaterThanEqual(gid, size))) return;

    vec3 uvw = (vec3(gid) + 0.5) / vec3(size);

    float theta = uvw.x * 2.0 * PI;
    float r     = mix(rMin, rMax, uvw.y);
    float z     = mix(zMin, zMax, uvw.z);

    float omega = 1.4 * pow(r, -1.5);
    theta += omega * uTime;
    theta = mod(theta, 2.0 * PI);

    float H = abs(z);
    float diskThickness = 0.3;
    float vert = exp(-pow(H / diskThickness, 2.5));

    float radial = exp(-r * 0.08);
    
    float ringFreq = 30.0;
    float ring = 0.5 + 0.5 * sin(r * ringFreq + uTime * 0.15);
    float ringMix = mix(1.0, ring, 0.15);
    
    float turb = hash(vec3(theta * 40.0, r * 6.0, z * 20.0 + uTime * 0.3));
    float smallTurb = mix(0.7, 1.3, turb);

    float density = radial * vert * ringMix;
    density *= smallTurb;

    density *= smoothstep(rMin * 1.05, rMin * 1.2, r);
    density = max(density, 0.0);

    float temp = mix(1.0, 0.3, h / diskThickness);

    imageStore(diskVolume, gid, vec4(density, temp, smallTurb, 1.0));
}

